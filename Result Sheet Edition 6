import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
from reportlab.lib.pagesizes import letter, landscape
from reportlab.pdfgen import canvas
from reportlab.lib import colors
from reportlab.platypus import Table, TableStyle, Paragraph, Spacer, PageBreak, Image as RLImage
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.enums import TA_CENTER, TA_RIGHT, TA_LEFT
import webbrowser
import os
from datetime import datetime
import json
import sqlite3
import numpy as np
# import matplotlib.pyplot as plt # Import if plotting is added
# from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg # Import if plotting is added
# import io # Import if plotting is added

# --- Constants for consistent styling and paths ---
# Paths
APP_ICON_FILENAME = 'gpa_icon.ico'
DB_FILENAME = 'gpa_data.db'
SETTINGS_FILENAME = 'app_settings.json' # For application-level settings

# Colors
BG_COLOR = "#e8f0f8"
HEADER_COLOR = "#2c3e50"
SUBHEADER_COLOR = "#7f8c8d"
PRIMARY_BUTTON_COLOR = "#3498db"
SUCCESS_BUTTON_COLOR = "#2ecc71"
DANGER_BUTTON_COLOR = "#e74c3c"
INFO_BUTTON_COLOR = "#9b59b6"
TEXT_COLOR = "#333333"
ERROR_COLOR = "#e74c3c"
HIGHLIGHT_COLOR = "#3498db"
TABLE_HEADER_BG = colors.HexColor('#ADD8E6')
TABLE_ROW_BG = colors.HexColor('#F0F8FF')
TABLE_GRID_COLOR = colors.grey

# Fonts
FONT_FAMILY = 'Segoe UI'
HEADER_FONT_SIZE = 18
SUBHEADER_FONT_SIZE = 12
NORMAL_FONT_SIZE = 11
SMALL_FONT_SIZE = 9
GPA_FONT_SIZE = 18
BUTTON_FONT_SIZE = 11

# --- Database Manager Class ---
class DatabaseManager:
    def __init__(self, db_path):
        self.db_path = db_path
        self._create_tables()

    def _get_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row # Allows accessing columns by name
        return conn

    def _create_tables(self):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS students (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                entry_date TEXT NOT NULL,
                cumulative_gpa REAL DEFAULT 0.0,
                num_subjects INTEGER DEFAULT 0
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS subjects (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                student_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                mark REAL NOT NULL,
                credits INTEGER DEFAULT 0,
                semester TEXT,
                grade TEXT,
                subject_gpa REAL,
                FOREIGN KEY (student_id) REFERENCES students (id) ON DELETE CASCADE
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS grading_scales (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                rules TEXT NOT NULL -- JSON string of rules
            )
        ''')
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS app_settings (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        ''')
        conn.commit()
        conn.close()
        self._add_default_grading_scale()
        self._initialize_app_settings()

    def _add_default_grading_scale(self):
        conn = self._get_connection()
        cursor = conn.cursor()
        default_scale_name = "Standard 5.0 Scale"
        default_rules = {
            "80-100": 5.00,
            "70-79": 4.00,
            "60-69": 3.50,
            "50-59": 3.00,
            "40-49": 2.00,
            "0-39": 0.00
        }
        try:
            cursor.execute("INSERT INTO grading_scales (name, rules) VALUES (?, ?)",
                           (default_scale_name, json.dumps(default_rules)))
            conn.commit()
        except sqlite3.IntegrityError:
            # Scale already exists
            pass
        conn.close()

    def _initialize_app_settings(self):
        conn = self._get_connection()
        cursor = conn.cursor()
        settings = {
            "institution_name": "University of Excellence",
            "logo_path": "",
            "active_grading_scale_id": self.get_grading_scales()[0]['id'] if self.get_grading_scales() else ""
        }
        for key, value in settings.items():
            cursor.execute("INSERT OR IGNORE INTO app_settings (key, value) VALUES (?, ?)", (key, str(value)))
        conn.commit()
        conn.close()

    def get_setting(self, key):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT value FROM app_settings WHERE key = ?", (key,))
        result = cursor.fetchone()
        conn.close()
        return result['value'] if result else None

    def update_setting(self, key, value):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("INSERT OR REPLACE INTO app_settings (key, value) VALUES (?, ?)", (key, str(value)))
        conn.commit()
        conn.close()

    def add_student(self, name, entry_date):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("INSERT INTO students (name, entry_date) VALUES (?, ?)", (name, entry_date))
        student_id = cursor.lastrowid
        conn.commit()
        conn.close()
        return student_id

    def update_student_gpa_info(self, student_id, cumulative_gpa, num_subjects):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("UPDATE students SET cumulative_gpa = ?, num_subjects = ? WHERE id = ?",
                       (cumulative_gpa, num_subjects, student_id))
        conn.commit()
        conn.close()

    def get_students(self, search_query="", order_by="name ASC"):
        conn = self._get_connection()
        cursor = conn.cursor()
        query = "SELECT id, name, entry_date, cumulative_gpa, num_subjects FROM students"
        params = []
        if search_query:
            query += " WHERE name LIKE ?"
            params.append(f"%{search_query}%")
        query += f" ORDER BY {order_by}"
        cursor.execute(query, params)
        students = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return students

    def get_student_details(self, student_id):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT * FROM students WHERE id = ?", (student_id,))
        student = cursor.fetchone()
        if student:
            student_dict = dict(student)
            cursor.execute("SELECT * FROM subjects WHERE student_id = ?", (student_id,))
            student_dict['Subjects'] = [dict(row) for row in cursor.fetchall()]
            conn.close()
            return student_dict
        conn.close()
        return None

    def delete_student(self, student_id):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM students WHERE id = ?", (student_id,))
        conn.commit()
        conn.close()

    def add_subject(self, student_id, name, mark, credits, semester, grade, subject_gpa):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("INSERT INTO subjects (student_id, name, mark, credits, semester, grade, subject_gpa) VALUES (?, ?, ?, ?, ?, ?, ?)",
                       (student_id, name, mark, credits, semester, grade, subject_gpa))
        conn.commit()
        conn.close()

    def delete_subjects_for_student(self, student_id):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM subjects WHERE student_id = ?", (student_id,))
        conn.commit()
        conn.close()

    def get_grading_scales(self):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id, name, rules FROM grading_scales")
        scales = []
        for row in cursor.fetchall():
            scale_dict = dict(row)
            scale_dict['rules'] = json.loads(scale_dict['rules'])
            scales.append(scale_dict)
        conn.close()
        return scales

    def add_grading_scale(self, name, rules):
        conn = self._get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute("INSERT INTO grading_scales (name, rules) VALUES (?, ?)",
                           (name, json.dumps(rules)))
            conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False # Name already exists
        finally:
            conn.close()

    def update_grading_scale(self, scale_id, name, rules):
        conn = self._get_connection()
        cursor = conn.cursor()
        try:
            cursor.execute("UPDATE grading_scales SET name = ?, rules = ? WHERE id = ?",
                           (name, json.dumps(rules), scale_id))
            conn.commit()
            return True
        except sqlite3.IntegrityError:
            return False # Name already exists for another scale
        finally:
            conn.close()

    def delete_grading_scale(self, scale_id):
        conn = self._get_connection()
        cursor = conn.cursor()
        cursor.execute("DELETE FROM grading_scales WHERE id = ?", (scale_id,))
        conn.commit()
        conn.close()

# --- GPA Calculation Logic (Moved to a separate class/module for modularity) ---
class GPACalculator:
    def __init__(self, db_manager):
        self.db = db_manager
        self.active_scale_id = self.db.get_setting("active_grading_scale_id")
        self.active_grading_scale = self._load_active_grading_scale()
        
    def _load_active_grading_scale(self):
        scales = self.db.get_grading_scales()
        if not scales:
            return None # No scales defined
        
        # Try to find the active scale by ID, otherwise default to the first one
        for scale in scales:
            if str(scale['id']) == str(self.active_scale_id):
                return scale
        
        # If active_scale_id is not found or not set, use the first available scale
        if scales:
            self.active_scale_id = scales[0]['id']
            self.db.update_setting("active_grading_scale_id", self.active_scale_id)
            return scales[0]
        return None # Should not happen if _add_default_grading_scale runs

    def update_active_scale(self, scale_id):
        self.active_scale_id = scale_id
        self.db.update_setting("active_grading_scale_id", scale_id)
        self.active_grading_scale = self._load_active_grading_scale()

    def _mark_to_gpa(self, mark):
        if not self.active_grading_scale:
            # Fallback to hardcoded if no scale loaded
            return self._default_mark_to_gpa(mark)

        rules = self.active_grading_scale['rules']
        for range_str, gpa_value in rules.items():
            try:
                if '-' in range_str:
                    low, high = map(int, range_str.split('-'))
                    if low <= mark <= high:
                        return gpa_value
                elif '<' in range_str: # e.g., "<40"
                    threshold = int(range_str.replace('<', ''))
                    if mark < threshold:
                        return gpa_value
                elif '>' in range_str: # e.g., ">80"
                    threshold = int(range_str.replace('>', ''))
                    if mark > threshold:
                        return gpa_value
            except ValueError:
                print(f"Warning: Invalid range format in grading scale rule: {range_str}")
                continue
        return 0.00 # Default for marks not covered

    def _default_mark_to_gpa(self, mark):
        """Hardcoded fallback GPA conversion."""
        if 80 <= mark <= 100: return 5.00
        elif 70 <= mark <= 79: return 4.00
        elif 60 <= mark <= 69: return 3.50
        elif 50 <= mark <= 59: return 3.00
        elif 40 <= mark <= 49: return 2.00
        else: return 0.00

    def _get_letter_grade(self, mark):
        """Converts a numerical mark to a letter grade."""
        # This can also be made configurable in the future
        if 80 <= mark <= 100: return "A+"
        elif 70 <= mark <= 79: return "A"
        elif 60 <= mark <= 69: return "A-"
        elif 50 <= mark <= 59: return "B"
        elif 40 <= mark <= 49: return "C"
        else: return "F"

    def calculate_overall_gpa(self, subjects_data, weighted=False):
        if not subjects_data:
            return 0.0
        
        if weighted:
            total_gpa_points = 0
            total_credits = 0
            for sub in subjects_data:
                gpa = self._mark_to_gpa(sub['Mark'])
                credits = int(sub.get('Credits', 0)) # Ensure credits are used
                total_gpa_points += gpa * credits
                total_credits += credits
            return total_gpa_points / total_credits if total_credits > 0 else 0.0
        else:
            total_gpa_points = sum(self._mark_to_gpa(sub['Mark']) for sub in subjects_data)
            return total_gpa_points / len(subjects_data)

    def calculate_semester_gpa(self, subjects_data):
        semesters_gpa = {}
        for sub in subjects_data:
            semester = sub.get('Semester', 'Unassigned')
            if semester not in semesters_gpa:
                semesters_gpa[semester] = {'marks': [], 'credits': []}
            semesters_gpa[semester]['marks'].append(sub['Mark'])
            semesters_gpa[semester]['credits'].append(sub.get('Credits', 0))
        
        results = {}
        for semester, data in semesters_gpa.items():
            temp_subjects = [{'Mark': m, 'Credits': c} for m, c in zip(data['marks'], data['credits'])]
            results[semester] = self.calculate_overall_gpa(temp_subjects, weighted=True)
        return results

# --- Report Generator Class ---
class ReportGenerator:
    def __init__(self, db_manager, gpa_calculator):
        self.db = db_manager
        self.gpa_calc = gpa_calculator
        self.styles = getSampleStyleSheet()
        self.institution_name = self.db.get_setting("institution_name")
        self.logo_path = self.db.get_setting("logo_path")

        # Custom styles for reports
        self.styles.add(ParagraphStyle(name='ReportTitle',
                                       fontName='Helvetica-Bold',
                                       fontSize=24,
                                       leading=28,
                                       alignment=TA_CENTER,
                                       spaceAfter=15))
        self.styles.add(ParagraphStyle(name='ReportSubtitle',
                                       fontName='Helvetica',
                                       fontSize=14,
                                       leading=16,
                                       alignment=TA_CENTER,
                                       spaceAfter=25))
        self.styles.add(ParagraphStyle(name='SectionHeader',
                                       fontName='Helvetica-Bold',
                                       fontSize=14,
                                       leading=16,
                                       spaceBefore=20,
                                       spaceAfter=10,
                                       textColor=colors.darkblue))
        self.styles.add(ParagraphStyle(name='NormalSmall',
                                       fontName='Helvetica',
                                       fontSize=10,
                                       leading=12))
        self.styles.add(ParagraphStyle(name='Disclaimer',
                                       fontName='Helvetica-Oblique',
                                       fontSize=9,
                                       leading=11,
                                       alignment=TA_CENTER,
                                       spaceBefore=20))

    def _generate_student_story(self, student_data, width, height, include_page_break=False):
        story = []

        # Institution Name & Logo (if available)
        if self.logo_path and os.path.exists(self.logo_path):
            try:
                img = RLImage(self.logo_path, width=1*inch, height=1*inch)
                img.hAlign = 'CENTER'
                story.append(img)
                story.append(Spacer(1, 0.2 * inch))
            except Exception as e:
                print(f"Could not load logo: {e}")
                pass # Continue without logo

        story.append(Paragraph(self.institution_name, self.styles['ReportTitle']))
        story.append(Paragraph("Academic Performance Report", self.styles['ReportSubtitle']))
        story.append(Spacer(1, 0.4 * inch))

        # Student Information
        story.append(Paragraph("Student Details", self.styles['SectionHeader']))
        student_info_data = [
            ["Student Name:", student_data['name']],
            ["Entry Date:", student_data['entry_date']],
            ["Total Subjects:", str(student_data['num_subjects'])],
            ["Overall GPA:", f"{student_data['cumulative_gpa']:.2f}"]
        ]
        info_table = Table(student_info_data, colWidths=[1.5*inch, 4*inch])
        info_table.setStyle(TableStyle([
            ('FONTNAME', (0,0), (-1,-1), 'Helvetica'),
            ('FONTNAME', (0,0), (0,-1), 'Helvetica-Bold'),
            ('ALIGN', (0,0), (-1,-1), 'LEFT'),
            ('VALIGN', (0,0), (-1,-1), 'TOP'),
            ('BOTTOMPADDING', (0,0), (-1,-1), 6),
            ('LEFTPADDING', (0,0), (-1,-1), 0),
        ]))
        story.append(info_table)
        story.append(Spacer(1, 0.3 * inch))

        # Subject Details Table
        story.append(Paragraph("Subject Breakdown", self.styles['SectionHeader']))
        table_data = [["Subject", "Mark", "Credits", "Semester", "Grade", "Subject GPA"]]
        for subject in student_data["Subjects"]:
            table_data.append([
                subject["name"],
                f"{subject['mark']:.2f}",
                str(subject['credits']),
                subject['semester'] if subject['semester'] else "N/A",
                subject["grade"],
                f"{subject['subject_gpa']:.2f}"
            ])

        table = Table(table_data, colWidths=[1.8*inch, 0.8*inch, 0.8*inch, 1*inch, 0.8*inch, 1*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), TABLE_HEADER_BG),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('ALIGN', (0, 0), (0, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('BACKGROUND', (0, 1), (-1, -1), TABLE_ROW_BG),
            ('GRID', (0, 0), (-1, -1), 1, TABLE_GRID_COLOR),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 6),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ]))
        story.append(table)
        story.append(Spacer(1, 0.3 * inch))

        # Semester GPAs (if applicable)
        sem_gpas = self.gpa_calc.calculate_semester_gpa(student_data['Subjects'])
        if sem_gpas:
            story.append(Paragraph("Semester-wise GPA", self.styles['SectionHeader']))
            sem_data = [["Semester", "GPA"]]
            for sem, gpa in sem_gpas.items():
                sem_data.append([sem, f"{gpa:.2f}"])
            sem_table = Table(sem_data, colWidths=[2*inch, 1*inch])
            sem_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), TABLE_HEADER_BG),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('ALIGN', (0, 0), (0, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
                ('BACKGROUND', (0, 1), (-1, -1), TABLE_ROW_BG),
                ('GRID', (0, 0), (-1, -1), 1, TABLE_GRID_COLOR),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ]))
            story.append(sem_table)
            story.append(Spacer(1, 0.3 * inch))

        # Disclaimer / Footer
        story.append(Paragraph("This report is generated by the Academic Performance Analyzer. All calculations are based on the currently active grading scale.", self.styles['Disclaimer']))
        story.append(Paragraph(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", self.styles['Disclaimer']))

        if include_page_break:
            story.append(PageBreak())
        return story

    # def _create_gpa_chart(self, student_data):
    #     """Generates a simple bar chart of subject GPAs."""
    #     subject_names = [s['name'] for s in student_data['Subjects']]
    #     subject_gpas = [s['subject_gpa'] for s in student_data['Subjects']]

    #     if not subject_names:
    #         return None

    #     fig, ax = plt.subplots(figsize=(6, 3))
    #     ax.bar(subject_names, subject_gpas, color=HIGHLIGHT_COLOR)
    #     ax.set_ylabel('GPA')
    #     ax.set_title('Subject GPAs')
    #     ax.set_ylim(0, 5.0) # Assuming a 5.0 scale
    #     plt.xticks(rotation=45, ha='right')
    #     plt.tight_layout()

    #     # Save plot to a BytesIO object
    #     buffer = io.BytesIO()
    #     plt.savefig(buffer, format='png', bbox_inches='tight')
    #     buffer.seek(0)
    #     plt.close(fig) # Close the figure to free memory
    #     return buffer

    def generate_pdf_report(self, student_data, file_path):
        doc = canvas.Canvas(file_path, pagesize=landscape(letter))
        width, height = landscape(letter)
        story = self._generate_student_story(student_data, width, height)
        
        # Add a chart if matplotlib is enabled and data exists
        # chart_buffer = self._create_gpa_chart(student_data)
        # if chart_buffer:
        #     story.insert(-2, Paragraph("Performance Overview", self.styles['SectionHeader']))
        #     chart_img = RLImage(chart_buffer, width=6*inch, height=3*inch)
        #     chart_img.hAlign = 'CENTER'
        #     story.insert(-2, chart_img)
        #     story.insert(-2, Spacer(1, 0.3 * inch))


        # Build the PDF document
        from reportlab.platypus import SimpleDocTemplate
        doc_template = SimpleDocTemplate(file_path, pagesize=landscape(letter))
        doc_template.build(story)


    def generate_all_pdf_report(self, all_students_data, file_path):
        doc_template = SimpleDocTemplate(file_path, pagesize=landscape(letter))
        full_story = []
        for i, student_data in enumerate(all_students_data):
            # Fetch full details for each student as the 'all_students_data' might be summary
            full_student_details = self.db.get_student_details(student_data['id'])
            if full_student_details:
                # Generate story for each student, add page break if not the last student
                story_part = self._generate_student_story(full_student_details, 
                                                          landscape(letter)[0], 
                                                          landscape(letter)[1], 
                                                          include_page_break=(i < len(all_students_data) - 1))
                full_story.extend(story_part)
        
        doc_template.build(full_story)

# --- CSV Exporter Class ---
class CSVExporter:
    def export_single_student_csv(self, student_data, file_path):
        df_subjects = pd.DataFrame(student_data["Subjects"])
        student_info_df = pd.DataFrame({
            "Student Name": [student_data['name']],
            "Entry Date": [student_data['entry_date']],
            "Number of Subjects": [student_data['num_subjects']],
            "Overall GPA": [f"{student_data['cumulative_gpa']:.2f}"]
        })
        with open(file_path, 'w', newline='', encoding='utf-8') as f:
            f.write("--- Student General Information ---\n")
            student_info_df.to_csv(f, index=False)
            f.write("\n--- Subject Details ---\n")
            df_subjects.to_csv(f, index=False)
            f.write("\n")

    def export_all_students_csv(self, all_students_data, file_path, db_manager):
        with open(file_path, 'w', newline='', encoding='utf-8') as f:
            f.write(f"Academic Performance Analyzer - All Students Report\n")
            f.write(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
            f.write("Student Name,Entry Date,Overall GPA,Subject Name,Mark,Credits,Semester,Grade,Subject GPA\n")
            
            for student in all_students_data:
                full_student_details = db_manager.get_student_details(student['id'])
                if not full_student_details:
                    continue # Skip if details can't be fetched

                student_name_csv = f'"{full_student_details["name"]}"'
                entry_date_csv = f'"{full_student_details["entry_date"]}"'
                overall_gpa_csv = f'"{full_student_details["cumulative_gpa"]:.2f}"'
                
                for i, subject in enumerate(full_student_details["Subjects"]):
                    subject_name_csv = f'"{subject["name"]}"'
                    mark_csv = f'"{subject["mark"]:.2f}"'
                    credits_csv = f'"{subject["credits"]}"'
                    semester_csv = f'"{subject["semester"] if subject["semester"] else "N/A"}"'
                    grade_csv = f'"{subject["grade"]}"'
                    subject_gpa_csv = f'"{subject["subject_gpa"]:.2f}"'
                    
                    if i == 0:
                        f.write(f"{student_name_csv},{entry_date_csv},{overall_gpa_csv},")
                    else:
                        f.write(",,,")
                    f.write(f"{subject_name_csv},{mark_csv},{credits_csv},{semester_csv},{grade_csv},{subject_gpa_csv}\n")
                f.write("\n")

# --- CSV Importer Class ---
class CSVImporter:
    def __init__(self, db_manager, gpa_calculator):
        self.db = db_manager
        self.gpa_calc = gpa_calculator

    def import_data_from_csv(self, file_path):
        try:
            df = pd.read_csv(file_path)
            
            # Expected columns: "Student Name", "Subject Name", "Mark", "Credits", "Semester"
            # Optional: "Entry Date" (will default to current if not provided)

            required_cols = ["Student Name", "Subject Name", "Mark"]
            if not all(col in df.columns for col in required_cols):
                raise ValueError(f"Missing one or more required columns. Expected: {', '.join(required_cols)}")

            imported_count = 0
            for student_name in df["Student Name"].unique():
                student_df = df[df["Student Name"] == student_name]
                
                entry_date = student_df["Entry Date"].iloc[0] if "Entry Date" in student_df.columns and not pd.isna(student_df["Entry Date"].iloc[0]) else datetime.now().strftime("%Y-%m-%d %H:%M:%S")

                student_id = self.db.add_student(student_name, entry_date)
                
                subjects_for_gpa = []
                for _, row in student_df.iterrows():
                    subject_name = row["Subject Name"]
                    mark = float(row["Mark"])
                    credits = int(row["Credits"]) if "Credits" in row and not pd.isna(row["Credits"]) else 0
                    semester = str(row["Semester"]) if "Semester" in row and not pd.isna(row["Semester"]) else None
                    
                    subject_gpa = self.gpa_calc._mark_to_gpa(mark)
                    grade = self.gpa_calc._get_letter_grade(mark)
                    
                    self.db.add_subject(student_id, subject_name, mark, credits, semester, grade, subject_gpa)
                    subjects_for_gpa.append({'Mark': mark, 'Credits': credits})

                overall_gpa = self.gpa_calc.calculate_overall_gpa(subjects_for_gpa, weighted=True)
                self.db.update_student_gpa_info(student_id, overall_gpa, len(subjects_for_gpa))
                imported_count += 1
            return imported_count
        except Exception as e:
            raise Exception(f"Error importing CSV: {e}")

# --- Grading Scale Manager Class ---
class GradingScaleManager:
    def __init__(self, parent_app, db_manager, gpa_calculator):
        self.parent_app = parent_app
        self.db = db_manager
        self.gpa_calc = gpa_calculator
        self.grading_scale_window = None
        self.selected_scale_id = None
        
    def show_grading_scale_manager(self):
        if self.grading_scale_window and self.grading_scale_window.winfo_exists():
            self.grading_scale_window.lift()
            return

        self.grading_scale_window = tk.Toplevel(self.parent_app.root)
        self.grading_scale_window.title("Manage Grading Scales")
        self.grading_scale_window.geometry("700x550")
        self.grading_scale_window.transient(self.parent_app.root)
        self.grading_scale_window.grab_set()

        main_frame = ttk.Frame(self.grading_scale_window, padding=15, style='TFrame')
        main_frame.pack(fill='both', expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        # Scale List
        list_frame = ttk.LabelFrame(main_frame, text="Existing Scales", padding=10)
        list_frame.grid(row=0, column=0, columnspan=2, sticky='nsew', padx=5, pady=5)
        list_frame.rowconfigure(0, weight=1)
        list_frame.columnconfigure(0, weight=1)

        self.scale_tree = ttk.Treeview(list_frame, columns=("ID", "Name", "Active"), show="headings", selectmode='browse')
        self.scale_tree.heading("ID", text="ID", anchor='center')
        self.scale_tree.heading("Name", text="Scale Name", anchor='w')
        self.scale_tree.heading("Active", text="Active", anchor='center')
        self.scale_tree.column("ID", width=50, anchor='center', stretch=tk.NO)
        self.scale_tree.column("Name", width=250, anchor='w')
        self.scale_tree.column("Active", width=80, anchor='center', stretch=tk.NO)
        self.scale_tree.pack(fill='both', expand=True)
        self.scale_tree.bind("<<TreeviewSelect>>", self._on_scale_select)
        
        list_scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=self.scale_tree.yview)
        list_scrollbar.pack(side="right", fill="y")
        self.scale_tree.configure(yscrollcommand=list_scrollbar.set)
        
        # Scale Management Buttons
        button_frame = ttk.Frame(main_frame, style='TFrame')
        button_frame.grid(row=1, column=0, columnspan=2, pady=10)
        
        ttk.Button(button_frame, text="Add New Scale", command=self._add_scale_dialog, style='Success.TButton').pack(side='left', padx=5)
        self.edit_scale_btn = ttk.Button(button_frame, text="Edit Selected Scale", command=self._edit_scale_dialog, style='Primary.TButton', state='disabled')
        self.edit_scale_btn.pack(side='left', padx=5)
        self.delete_scale_btn = ttk.Button(button_frame, text="Delete Selected Scale", command=self._delete_scale, style='Danger.TButton', state='disabled')
        self.delete_scale_btn.pack(side='left', padx=5)
        self.set_active_scale_btn = ttk.Button(button_frame, text="Set Active", command=self._set_active_scale, style='Info.TButton', state='disabled')
        self.set_active_scale_btn.pack(side='left', padx=5)

        self._load_scales_to_treeview()
        
    def _load_scales_to_treeview(self):
        for i in self.scale_tree.get_children():
            self.scale_tree.delete(i)
        
        scales = self.db.get_grading_scales()
        active_scale_id = self.gpa_calc.active_scale_id # Get currently active ID

        for scale in scales:
            is_active = "Yes" if str(scale['id']) == str(active_scale_id) else "No"
            self.scale_tree.insert("", "end", iid=scale['id'], 
                                   values=(scale['id'], scale['name'], is_active))

    def _on_scale_select(self, event):
        selected_item = self.scale_tree.focus()
        if selected_item:
            self.selected_scale_id = self.scale_tree.item(selected_item, 'iid')
            self.edit_scale_btn.config(state='normal')
            self.delete_scale_btn.config(state='normal')
            self.set_active_scale_btn.config(state='normal')
            
            # Disable delete if it's the only scale
            if len(self.db.get_grading_scales()) <= 1:
                self.delete_scale_btn.config(state='disabled')
            # Disable 'Set Active' if already active
            if str(self.selected_scale_id) == str(self.gpa_calc.active_scale_id):
                self.set_active_scale_btn.config(state='disabled')
        else:
            self.selected_scale_id = None
            self.edit_scale_btn.config(state='disabled')
            self.delete_scale_btn.config(state='disabled')
            self.set_active_scale_btn.config(state='disabled')

    def _add_scale_dialog(self):
        self._open_scale_editor("Add New Grading Scale", None)

    def _edit_scale_dialog(self):
        if self.selected_scale_id:
            selected_scale = next((s for s in self.db.get_grading_scales() if s['id'] == self.selected_scale_id), None)
            if selected_scale:
                self._open_scale_editor("Edit Grading Scale", selected_scale)
        else:
            messagebox.showinfo("No Selection", "Please select a grading scale to edit.")

    def _open_scale_editor(self, title, scale_data=None):
        editor_window = tk.Toplevel(self.grading_scale_window)
        editor_window.title(title)
        editor_window.geometry("500x400")
        editor_window.transient(self.grading_scale_window)
        editor_window.grab_set()

        frame = ttk.Frame(editor_window, padding=10, style='TFrame')
        frame.pack(fill='both', expand=True)

        ttk.Label(frame, text="Scale Name:", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).pack(pady=5)
        scale_name_entry = ttk.Entry(frame, width=40, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        scale_name_entry.pack(pady=5)

        ttk.Label(frame, text="Rules (e.g., 80-100: 5.0, 70-79: 4.0):", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).pack(pady=5)
        rules_text = tk.Text(frame, height=8, width=50, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        rules_text.pack(pady=5)
        
        status_label = ttk.Label(frame, text="", foreground=ERROR_COLOR, font=(FONT_FAMILY, SMALL_FONT_SIZE))
        status_label.pack(pady=5)

        if scale_data:
            scale_name_entry.insert(0, scale_data['name'])
            rules_str = "\n".join([f"{r}: {g}" for r, g in scale_data['rules'].items()])
            rules_text.insert('1.0', rules_str)

        def save_scale():
            name = scale_name_entry.get().strip()
            rules_raw = rules_text.get('1.0', 'end').strip()

            if not name:
                status_label.config(text="Scale name cannot be empty.")
                return

            rules = {}
            try:
                for line in rules_raw.split('\n'):
                    if not line.strip(): continue
                    parts = line.split(':')
                    if len(parts) != 2:
                        raise ValueError(f"Invalid rule format: '{line}'. Expected 'Range: GPA'.")
                    
                    range_key = parts[0].strip()
                    gpa_val = float(parts[1].strip())
                    rules[range_key] = gpa_val
            except ValueError as e:
                status_label.config(text=f"Error in rules: {e}")
                return

            if not rules:
                status_label.config(text="No valid grading rules entered.")
                return

            if scale_data: # Editing existing scale
                success = self.db.update_grading_scale(scale_data['id'], name, rules)
                if success:
                    messagebox.showinfo("Success", "Grading scale updated successfully.")
                    editor_window.destroy()
                    self._load_scales_to_treeview()
                else:
                    status_label.config(text="Error: Scale name already exists.")
            else: # Adding new scale
                success = self.db.add_grading_scale(name, rules)
                if success:
                    messagebox.showinfo("Success", "Grading scale added successfully.")
                    editor_window.destroy()
                    self._load_scales_to_treeview()
                else:
                    status_label.config(text="Error: Scale name already exists.")
        
        ttk.Button(frame, text="Save Scale", command=save_scale, style='Success.TButton').pack(pady=10)

    def _delete_scale(self):
        if self.selected_scale_id:
            if str(self.selected_scale_id) == str(self.gpa_calc.active_scale_id):
                messagebox.showerror("Error", "Cannot delete the active grading scale. Please set another scale as active first.")
                return

            if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this grading scale? This action cannot be undone."):
                self.db.delete_grading_scale(self.selected_scale_id)
                messagebox.showinfo("Success", "Grading scale deleted successfully.")
                self._load_scales_to_treeview()
                self.selected_scale_id = None
                self._on_scale_select(None) # Reset button states
        else:
            messagebox.showinfo("No Selection", "Please select a grading scale to delete.")

    def _set_active_scale(self):
        if self.selected_scale_id:
            self.gpa_calc.update_active_scale(self.selected_scale_id)
            messagebox.showinfo("Success", f"'{self.scale_tree.item(self.selected_scale_id, 'values')[1]}' is now the active grading scale.")
            self._load_scales_to_treeview() # Refresh treeview to show active status
            self._on_scale_select(None) # Reset button states
        else:
            messagebox.showinfo("No Selection", "Please select a grading scale to set as active.")

# --- Main Application Class ---
class ProfessionalGPAApp:
    def __init__(self, root):
        self.root = root
        self.db = DatabaseManager(DB_FILENAME)
        self.gpa_calculator = GPACalculator(self.db)
        self.report_generator = ReportGenerator(self.db, self.gpa_calculator)
        self.csv_exporter = CSVExporter()
        self.csv_importer = CSVImporter(self.db, self.gpa_calculator)
        self.grading_scale_manager = GradingScaleManager(self, self.db, self.gpa_calculator)

        self._configure_root_window()
        self._set_app_icon()
        self._apply_styling()

        self.student_name_entry_widget = None
        self.num_subjects_entry_widget = None
        self.subject_entries = []
        self.mark_entries = []
        self.credits_entries = []
        self.semester_entries = []
        self.output_label = None
        self.canvas_scroll_bind_id = None
        self.scrollable_frame_id = None
        self.current_student_id = None # Store ID for current student being viewed

        self.show_welcome_screen()
        
    def _configure_root_window(self):
        self.root.title(f"üéì Academic Performance Analyzer - {self.db.get_setting('institution_name')}")
        self.root.geometry("1000x750") # Increased default size
        self.root.configure(bg=BG_COLOR)
        self.root.resizable(True, True)
        self.root.minsize(900, 700)

        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)

    def _set_app_icon(self):
        try:
            script_dir = None
            if '__file__' in locals():
                script_dir = os.path.dirname(os.path.abspath(__file__))
            else:
                script_dir = os.getcwd() 
                print("Warning: '__file__' not defined. Using current working directory for icon path.")

            if script_dir:
                icon_path = os.path.join(script_dir, APP_ICON_FILENAME)
                if os.path.exists(icon_path):
                    self.root.iconbitmap(icon_path)
                else:
                    print(f"Warning: {APP_ICON_FILENAME} not found at {icon_path}. Skipping icon setting.")
            else:
                print("Warning: Could not determine script directory. Skipping icon setting.")
        except Exception as e:
            print(f"Error setting icon: {e}. Ensure '{APP_ICON_FILENAME}' is in the same directory as the script.")
            pass

    def _apply_styling(self):
        self.style = ttk.Style()
        self.style.theme_use('clam')
        
        self.style.configure('TFrame', background=BG_COLOR)
        self.style.configure('TLabel', background=BG_COLOR, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        self.style.configure('Header.TLabel', font=(FONT_FAMILY, HEADER_FONT_SIZE, 'bold'), foreground=HEADER_COLOR)
        self.style.configure('SubHeader.TLabel', font=(FONT_FAMILY, SUBHEADER_FONT_SIZE, 'italic'), foreground=SUBHEADER_COLOR)
        
        self.style.configure('TEntry', fieldbackground='#ffffff', bordercolor='#cccccc', borderradius=5)

        self.style.configure('TButton', font=(FONT_FAMILY, BUTTON_FONT_SIZE, 'bold'), padding=8, relief='flat', borderwidth=0)
        self.style.map('TButton',
                       background=[('active', '#d0d0d0')],
                       foreground=[('active', 'black')])

        self.style.configure('Primary.TButton', foreground='white', background=PRIMARY_BUTTON_COLOR)
        self.style.map('Primary.TButton',
                        background=[('pressed', '#2980b9'), ('active', '#2980b9')],
                        foreground=[('pressed', 'white'), ('active', 'white')])

        self.style.configure('Success.TButton', foreground='white', background=SUCCESS_BUTTON_COLOR)
        self.style.map('Success.TButton',
                        background=[('pressed', '#27ae60'), ('active', '#27ae60')],
                        foreground=[('pressed', 'white'), ('active', 'white')])

        self.style.configure('Danger.TButton', foreground='white', background=DANGER_BUTTON_COLOR)
        self.style.map('Danger.TButton',
                        background=[('pressed', '#c0392b'), ('active', '#c0392b')],
                        foreground=[('pressed', 'white'), ('active', 'white')])

        self.style.configure('Info.TButton', foreground='white', background=INFO_BUTTON_COLOR)
        self.style.map('Info.TButton',
                        background=[('pressed', '#8e44ad'), ('active', '#8e44ad')],
                        foreground=[('pressed', 'white'), ('active', 'white')])
        
        self.style.configure('Treeview',
                             background="#ffffff",
                             foreground=TEXT_COLOR,
                             rowheight=25,
                             fieldbackground="#ffffff")
        self.style.map('Treeview', background=[('selected', HIGHLIGHT_COLOR)])
        self.style.configure('Treeview.Heading',
                             font=(FONT_FAMILY, 10, 'bold'),
                             background='#f0f0f0',
                             foreground=HEADER_COLOR,
                             relief='raised')
        
    def clear_window(self):
        if self.canvas_scroll_bind_id:
            self.root.unbind("<MouseWheel>", self.canvas_scroll_bind_id)
            self.canvas_scroll_bind_id = None
        for widget in self.root.winfo_children():
            widget.destroy()

    def show_welcome_screen(self):
        self.clear_window()
        main_container = ttk.Frame(self.root, style='TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky='nsew')
        main_container.grid_rowconfigure(0, weight=1)
        main_container.grid_columnconfigure(0, weight=1)

        content_frame = ttk.Frame(main_container, style='TFrame')
        content_frame.pack(expand=True, fill='both', pady=20)

        ttk.Label(content_frame, text="Academic Performance Analyzer", style='Header.TLabel').pack(pady=(10, 5))
        ttk.Label(content_frame, text="Comprehensive GPA Calculation and Reporting System", 
                  style='SubHeader.TLabel').pack(pady=(0, 20))
        
        logo_placeholder = ttk.Frame(content_frame, height=120, width=120, relief='groove',
                                     borderwidth=1, style='TFrame')
        logo_placeholder.pack(pady=15)
        ttk.Label(logo_placeholder, text="üéì", font=(FONT_FAMILY, 48, 'bold'), foreground=HIGHLIGHT_COLOR, background=BG_COLOR).place(relx=0.5, rely=0.5, anchor='center')
        
        ttk.Label(content_frame, text="Key Features:", font=(FONT_FAMILY, 12, 'bold')).pack(anchor='center', pady=(15, 10))

        features = [
            "‚úì Calculate GPA for individual students or groups",
            "‚úì Customize grading scales to fit your institution's standards",
            "‚úì Track subjects with credit hours and calculate weighted GPA",
            "‚úì Generate detailed PDF reports (individual and aggregate)",
            "‚úì Export and Import data via CSV for seamless integration",
            "‚úì Comprehensive dashboard for student management",
            "‚úì User-friendly interface with intuitive navigation"
        ]
        
        for feature in features:
            ttk.Label(content_frame, text=feature, font=(FONT_FAMILY, 11)).pack(anchor='center', pady=2, padx=10)
        
        button_frame = ttk.Frame(content_frame, padding="20 10")
        button_frame.pack(pady=(30, 10))
        
        ttk.Button(button_frame, text="Manage Students", style='Success.TButton', 
                   command=self.show_dashboard).pack(side='left', padx=15)
        ttk.Button(button_frame, text="Settings", style='Info.TButton',
                   command=self.show_settings_dialog).pack(side='left', padx=15)
        ttk.Button(button_frame, text="Help", style='Info.TButton', 
                   command=self.show_help).pack(side='left', padx=15)
        ttk.Button(button_frame, text="Exit", style='Danger.TButton', 
                   command=self.root.quit).pack(side='left', padx=15)
        
        footer_frame = ttk.Frame(content_frame, padding="10 5")
        footer_frame.pack(side='bottom', fill='x', pady=(20, 0))
        
        ttk.Label(footer_frame, text=f"¬© {datetime.now().year} {self.db.get_setting('institution_name')} - Academic Tools Division", 
                  font=(FONT_FAMILY, 9, 'italic'), foreground="#95a5a6", anchor='center').pack(pady=5)
    
    def show_help(self):
        help_window = tk.Toplevel(self.root)
        help_window.title("Help Documentation")
        help_window.geometry("750x550")
        help_window.resizable(False, False)
        help_window.transient(self.root)
        help_window.grab_set()
        
        notebook = ttk.Notebook(help_window)
        notebook.pack(fill='both', expand=True, padx=15, pady=15)
        
        quick_start = ttk.Frame(notebook, padding=10)
        notebook.add(quick_start, text="Quick Start")
        quick_start_text = """
        **Academic Performance Analyzer - Quick Start Guide**
        
        This application helps you calculate and report student GPAs efficiently.
        
        1.  **Manage Students (Dashboard):**
            -   From the welcome screen, click "Manage Students".
            -   Here you can add new students, view/edit existing ones, or delete records.
            -   Use the search bar to find specific students.
        
        2.  **Add/Edit Student Information:**
            -   Click "Add New Student" or "View/Edit Selected" on the Dashboard.
            -   Enter student's full name, then specify number of subjects.
            -   For each subject, enter name, mark (0-100), credits, and semester.
            -   Credits are crucial for weighted GPA calculation. If not applicable, enter 0.
            -   Press `Enter` to navigate fields, "Submit Data" when done.
        
        3.  **View Results:**
            -   After submission, a detailed report for the current student appears.
            -   Navigate between student reports using "‚Üê Previous Student" and "Next Student ‚Üí".
        
        4.  **Export Options:**
            -   **Export Single PDF/CSV:** Generates report for the displayed student.
            -   **Export All to CSV/PDF:** Compiles reports for all students into one file.
        
        5.  **Import Data:**
            -   Use "Import Students from CSV" on the Dashboard to load data from a CSV file.
            -   CSV must contain "Student Name", "Subject Name", "Mark" columns. "Credits", "Semester", and "Entry Date" are optional.
        
        6.  **Settings:**
            -   Access "Settings" from the Welcome screen to change Institution Name, Logo Path, and manage Grading Scales.
        """
        self._create_scrollable_text_tab(quick_start, quick_start_text, help_window)
        
        grading_scale = ttk.Frame(notebook, padding=10)
        notebook.add(grading_scale, text="Grading Scale")
        scale_info = """
        **Customizable GPA Grading Scales:**
        
        This application allows you to define and use multiple grading scales. The default is a 5.0 scale.
        
        **Default Standard 5.0 Scale:**
        | Mark Range | Grade Points | Letter Grade |
        | :--------- | :----------- | :----------- |
        | 80-100     | 5.00         | A+           |
        | 70-79      | 4.00         | A            |
        | 60-69      | 3.50         | A-           |
        | 50-59      | 3.00         | B            |
        | 40-49      | 2.00         | C            |
        | Below 40   | 0.00         | F (Fail)     |
        
        **Final GPA Calculation:**
        The system calculates the **weighted average** of all individual subject grade points.
        (Sum of (Subject GPA * Credits)) / (Total Credits)
        If credits are not provided (or are 0), it defaults to a simple average.
        
        **Managing Scales:**
        Go to `Settings -> Manage Grading Scales` to add, edit, or delete scales.
        Rules should be entered as `MarkRange: GPA_Value` (e.g., `90-100: 4.0`, `<60: 0.0`).
        """
        self._create_scrollable_text_tab(grading_scale, scale_info, help_window)
        
        about = ttk.Frame(notebook, padding=10)
        notebook.add(about, text="About")
        about_info = f"""
        **Academic Performance Analyzer**
        
        Version: 3.0.0 (Professional Edition)
        Developed by: {self.db.get_setting('institution_name')} - Academic Tools Division
        Release Date: {datetime.now().strftime('%B %Y')}
        
        **Purpose:**
        This tool is designed to assist educational institutions and individuals in
        accurately calculating and presenting academic performance metrics (GPA)
        in a clear, professional, and easily digestible format.
        
        **Key Architectural Enhancements:**
        -   **Persistent Data Storage:** Utilizes SQLite database for reliable data management.
        -   **Modular Design:** Code is structured into dedicated classes (DatabaseManager, GPACalculator, ReportGenerator, CSVImporter/Exporter) for maintainability and scalability.
        -   **Configurable Grading Scales:** Empowers users to define and manage custom grading criteria.
        -   **Enhanced Reporting:** Generates richer PDF reports and flexible CSV exports.
        
        For technical support, feature requests, or collaboration inquiries, please contact:
        academicsupport@{self.db.get_setting('institution_name').lower().replace(' ', '')}.edu
        """
        self._create_scrollable_text_tab(about, about_info, help_window)
        
        ttk.Button(help_window, text="Close Help", command=help_window.destroy, style='Primary.TButton').pack(pady=15)

    def _create_scrollable_text_tab(self, parent_frame, text_content, top_level_window):
        text_widget = tk.Text(parent_frame, wrap='word', font=(FONT_FAMILY, 10),
                              bg="#ffffff", fg=TEXT_COLOR, relief='flat', padx=10, pady=10)
        text_widget.insert('end', text_content)
        text_widget.config(state='disabled')
        
        scrollbar = ttk.Scrollbar(parent_frame, orient='vertical', command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)
        
        text_widget.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

        text_widget.bind("<MouseWheel>", lambda e: text_widget.yview_scroll(int(-1*(e.delta/120)), "units"))
        parent_frame.bind("<MouseWheel>", lambda e: text_widget.yview_scroll(int(-1*(e.delta/120)), "units"))

    def show_settings_dialog(self):
        settings_window = tk.Toplevel(self.root)
        settings_window.title("Application Settings")
        settings_window.geometry("600x450")
        settings_window.transient(self.root)
        settings_window.grab_set()

        main_frame = ttk.Frame(settings_window, padding=20, style='TFrame')
        main_frame.pack(fill='both', expand=True)
        main_frame.columnconfigure(1, weight=1)

        # Institution Name
        ttk.Label(main_frame, text="Institution Name:", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).grid(row=0, column=0, sticky='w', pady=5, padx=5)
        self.institution_name_var = tk.StringVar(value=self.db.get_setting("institution_name"))
        institution_entry = ttk.Entry(main_frame, textvariable=self.institution_name_var, width=40, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        institution_entry.grid(row=0, column=1, sticky='ew', pady=5, padx=5)

        # Logo Path
        ttk.Label(main_frame, text="Institution Logo Path:", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).grid(row=1, column=0, sticky='w', pady=5, padx=5)
        self.logo_path_var = tk.StringVar(value=self.db.get_setting("logo_path"))
        logo_path_entry = ttk.Entry(main_frame, textvariable=self.logo_path_var, width=40, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        logo_path_entry.grid(row=1, column=1, sticky='ew', pady=5, padx=5)
        ttk.Button(main_frame, text="Browse...", command=self._browse_logo_path, style='TButton').grid(row=1, column=2, padx=5, sticky='e')

        # Active Grading Scale Selection
        ttk.Label(main_frame, text="Active Grading Scale:", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).grid(row=2, column=0, sticky='w', pady=10, padx=5)
        self.active_scale_combobox = ttk.Combobox(main_frame, state='readonly', font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        self.active_scale_combobox.grid(row=2, column=1, sticky='ew', pady=10, padx=5)
        self._load_grading_scales_for_combobox()
        
        # Button to manage grading scales
        ttk.Button(main_frame, text="Manage Grading Scales", command=self.grading_scale_manager.show_grading_scale_manager, style='Primary.TButton').grid(row=3, column=0, columnspan=3, pady=15)

        # Save and Cancel Buttons
        button_frame = ttk.Frame(main_frame, style='TFrame')
        button_frame.grid(row=4, column=0, columnspan=3, pady=20)
        ttk.Button(button_frame, text="Save Settings", command=lambda: self._save_settings(settings_window), style='Success.TButton').pack(side='left', padx=10)
        ttk.Button(button_frame, text="Cancel", command=settings_window.destroy, style='Danger.TButton').pack(side='left', padx=10)

    def _browse_logo_path(self):
        file_path = filedialog.askopenfilename(
            title="Select Institution Logo",
            filetypes=[("Image files", "*.png *.jpg *.jpeg *.gif *.bmp *.tiff *.ico")]
        )
        if file_path:
            self.logo_path_var.set(file_path)

    def _load_grading_scales_for_combobox(self):
        scales = self.db.get_grading_scales()
        scale_names = [scale['name'] for scale in scales]
        scale_ids = {scale['name']: scale['id'] for scale in scales}
        self.active_scale_combobox['values'] = scale_names
        
        # Set current active scale in combobox
        current_active_scale = next((s for s in scales if str(s['id']) == str(self.gpa_calculator.active_scale_id)), None)
        if current_active_scale:
            self.active_scale_combobox.set(current_active_scale['name'])
        
        self.scale_ids_map = scale_ids # Store map for later lookup

    def _save_settings(self, settings_window):
        institution_name = self.institution_name_var.get().strip()
        logo_path = self.logo_path_var.get().strip()
        selected_scale_name = self.active_scale_combobox.get()

        if not institution_name:
            messagebox.showerror("Error", "Institution Name cannot be empty.")
            return

        selected_scale_id = self.scale_ids_map.get(selected_scale_name)
        if not selected_scale_id:
            messagebox.showerror("Error", "Please select a valid grading scale.")
            return

        self.db.update_setting("institution_name", institution_name)
        self.db.update_setting("logo_path", logo_path)
        self.db.update_setting("active_grading_scale_id", selected_scale_id)
        
        # Update GPA Calculator's active scale immediately
        self.gpa_calculator.update_active_scale(selected_scale_id)
        self.root.title(f"üéì Academic Performance Analyzer - {institution_name}") # Update main window title
        
        messagebox.showinfo("Settings Saved", "Application settings updated successfully.")
        settings_window.destroy()

    def show_dashboard(self):
        self.clear_window()
        
        main_container = ttk.Frame(self.root, style='TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky='nsew')
        main_container.grid_rowconfigure(2, weight=1) # Treeview row
        main_container.grid_columnconfigure(0, weight=1)

        header_frame = ttk.Frame(main_container, padding="0 0 0 10")
        header_frame.grid(row=0, column=0, sticky='ew', padx=20, pady=(20, 10))
        ttk.Label(header_frame, text="Student Management Dashboard", style='Header.TLabel').pack(side='left')
        ttk.Button(header_frame, text="‚Üê Back to Welcome", style='Danger.TButton', 
                   command=self.show_welcome_screen).pack(side='right', padx=(10,0))

        # Search and Filter frame
        search_frame = ttk.Frame(main_container, padding="10")
        search_frame.grid(row=1, column=0, sticky='ew', padx=20, pady=5)
        search_frame.columnconfigure(1, weight=1)

        ttk.Label(search_frame, text="Search Student:", font=(FONT_FAMILY, NORMAL_FONT_SIZE, 'bold')).grid(row=0, column=0, sticky='w', padx=5)
        self.search_entry = ttk.Entry(search_frame, width=30, font=(FONT_FAMILY, NORMAL_FONT_SIZE))
        self.search_entry.grid(row=0, column=1, sticky='ew', padx=5)
        self.search_entry.bind('<KeyRelease>', self._update_student_list)

        ttk.Button(search_frame, text="Import Students from CSV", style='Info.TButton',
                   command=self._import_students_csv).grid(row=0, column=2, padx=10)

        # Student List Treeview
        tree_frame = ttk.Frame(main_container)
        tree_frame.grid(row=2, column=0, sticky='nsew', padx=20, pady=5)

        columns = ("ID", "Student Name", "Entry Date", "Subjects", "Overall GPA")
        self.student_tree = ttk.Treeview(tree_frame, columns=columns, show='headings', selectmode='browse')
        
        self.student_tree.heading("ID", text="ID", anchor='center')
        self.student_tree.heading("Student Name", text="Student Name", anchor='w')
        self.student_tree.heading("Entry Date", text="Entry Date", anchor='center')
        self.student_tree.heading("Subjects", text="Subjects", anchor='center')
        self.student_tree.heading("Overall GPA", text="Overall GPA", anchor='center')
        
        self.student_tree.column("ID", width=60, anchor='center', stretch=tk.NO)
        self.student_tree.column("Student Name", width=200, anchor='w')
        self.student_tree.column("Entry Date", width=150, anchor='center')
        self.student_tree.column("Subjects", width=80, anchor='center')
        self.student_tree.column("Overall GPA", width=100, anchor='center')
        
        self.student_tree.pack(side="left", fill="both", expand=True)
        self.student_tree.bind("<<TreeviewSelect>>", self._on_student_select)

        tree_scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.student_tree.yview)
        tree_scrollbar.pack(side="right", fill="y")
        self.student_tree.configure(yscrollcommand=tree_scrollbar.set)

        # Dashboard Action Buttons
        button_frame = ttk.Frame(main_container, padding="10")
        button_frame.grid(row=3, column=0, sticky='ew', padx=20, pady=(10, 20))
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)
        button_frame.columnconfigure(4, weight=1)


        ttk.Button(button_frame, text="Add New Student", style='Success.TButton', 
                   command=lambda: self.reset_main_input(student_id=None)).grid(row=0, column=0, padx=5, sticky='e')
        
        self.view_edit_btn = ttk.Button(button_frame, text="View/Edit Selected", style='Primary.TButton', 
                                        command=self._view_edit_selected_student, state='disabled')
        self.view_edit_btn.grid(row=0, column=1, padx=5)
        
        self.delete_btn = ttk.Button(button_frame, text="Delete Selected", style='Danger.TButton', 
                                     command=self._delete_selected_student, state='disabled')
        self.delete_btn.grid(row=0, column=2, padx=5)

        ttk.Button(button_frame, text="Export All to CSV", style='Info.TButton',
                   command=self._export_all_to_csv).grid(row=0, column=3, padx=5)
        ttk.Button(button_frame, text="Export All to PDF", style='Info.TButton',
                   command=self._export_all_to_pdf).grid(row=0, column=4, padx=5, sticky='w')

        self._update_student_list()

    def _update_student_list(self, event=None):
        search_query = self.search_entry.get().strip()
        students = self.db.get_students(search_query=search_query)
        
        # Clear existing entries
        for item in self.student_tree.get_children():
            self.student_tree.delete(item)
            
        for student in students:
            self.student_tree.insert("", "end", iid=student['id'],
                                     values=(student['id'], student['name'], student['entry_date'], 
                                             student['num_subjects'], f"{student['cumulative_gpa']:.2f}"))
        self._on_student_select(None) # Disable buttons if no selection

    def _on_student_select(self, event):
        selected_item = self.student_tree.focus()
        if selected_item:
            self.current_student_id = self.student_tree.item(selected_item, 'iid')
            self.view_edit_btn.config(state='normal')
            self.delete_btn.config(state='normal')
        else:
            self.current_student_id = None
            self.view_edit_btn.config(state='disabled')
            self.delete_btn.config(state='disabled')

    def _view_edit_selected_student(self):
        if self.current_student_id:
            self.show_student_result(student_id=self.current_student_id)
        else:
            messagebox.showinfo("No Selection", "Please select a student from the list.")

    def _delete_selected_student(self):
        if self.current_student_id:
            student_name = self.student_tree.item(self.current_student_id, 'values')[1]
            if messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete {student_name}'s record? This cannot be undone."):
                self.db.delete_student(self.current_student_id)
                messagebox.showinfo("Deleted", f"Record for {student_name} deleted successfully.")
                self._update_student_list()
        else:
            messagebox.showinfo("No Selection", "Please select a student to delete.")

    def _import_students_csv(self):
        file_path = filedialog.askopenfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Import Student Data from CSV"
        )
        if not file_path:
            return

        try:
            imported_count = self.csv_importer.import_data_from_csv(file_path)
            messagebox.showinfo("Import Successful", f"Successfully imported {imported_count} student records from {os.path.basename(file_path)}.")
            self._update_student_list() # Refresh dashboard
        except Exception as e:
            messagebox.showerror("Import Error", f"Failed to import data:\n{e}")

    def reset_main_input(self, student_id=None):
        self.clear_window()
        self.subject_entries = []
        self.mark_entries = []
        self.credits_entries = []
        self.semester_entries = []
        self.current_student_id = student_id # Store ID if editing existing student

        main_container = ttk.Frame(self.root, style='TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky='nsew')
        main_container.grid_rowconfigure(1, weight=1)
        main_container.grid_columnconfigure(0, weight=1)

        header_frame = ttk.Frame(main_container, padding="0 0 0 10")
        header_frame.grid(row=0, column=0, sticky='ew', padx=20, pady=(20, 10))
        
        ttk.Label(header_frame, text="Student Information Entry", style='Header.TLabel').pack(side='left')
        ttk.Button(header_frame, text="‚Üê Back to Dashboard", style='Danger.TButton', 
                   command=self.show_dashboard).pack(side='right', padx=(10,0))
        
        content_frame = ttk.Frame(main_container, padding="40")
        content_frame.grid(row=1, column=0, sticky='nsew', padx=40, pady=10)
        content_frame.columnconfigure(1, weight=1)
        
        ttk.Label(content_frame, text="Student Name:", font=(FONT_FAMILY, 12, 'bold')).grid(row=0, column=0, sticky='w', pady=(10, 15), padx=(0, 10))
        self.student_name_entry_widget = ttk.Entry(content_frame, width=40, font=(FONT_FAMILY, 12))
        self.student_name_entry_widget.grid(row=0, column=1, sticky='ew', pady=(10, 15))
        
        ttk.Label(content_frame, text="Number of Subjects:", font=(FONT_FAMILY, 12, 'bold')).grid(row=1, column=0, sticky='w', pady=(15, 15), padx=(0, 10))
        self.num_subjects_entry_widget = ttk.Entry(content_frame, width=40, font=(FONT_FAMILY, 12))
        self.num_subjects_entry_widget.grid(row=1, column=1, sticky='ew', pady=(15, 15))
        
        button_frame = ttk.Frame(content_frame, padding="20 0")
        button_frame.grid(row=2, column=0, columnspan=2, pady=(40, 10))
        
        ttk.Button(button_frame, text='Next ‚Üí', style='Primary.TButton', 
                   command=self.generate_subject_inputs).pack(side='right', padx=10)
        
        self.output_label = ttk.Label(content_frame, text='', foreground=ERROR_COLOR, font=(FONT_FAMILY, 10, 'italic'))
        self.output_label.grid(row=3, column=0, columnspan=2, pady=(10, 0))
        
        self.student_name_entry_widget.focus_set()
        self.student_name_entry_widget.bind('<Return>', lambda e: self.num_subjects_entry_widget.focus_set())
        self.num_subjects_entry_widget.bind('<Return>', lambda e: self.generate_subject_inputs())

        # If editing an existing student, load their data
        if self.current_student_id:
            student_data = self.db.get_student_details(self.current_student_id)
            if student_data:
                self.student_name_entry_widget.insert(0, student_data['name'])
                self.num_subjects_entry_widget.insert(0, student_data['num_subjects'])
                # Disable changing these fields for existing students, they are fixed for data entry step
                self.student_name_entry_widget.config(state='readonly')
                self.num_subjects_entry_widget.config(state='readonly')
                # Immediately generate subjects input if it's an edit operation
                self.generate_subject_inputs(load_data=True)

    def generate_subject_inputs(self, load_data=False):
        name = self.student_name_entry_widget.get().strip()
        num_subjects_str = self.num_subjects_entry_widget.get().strip()
        
        if not name:
            self.output_label.config(text="Student Name cannot be empty.")
            self.student_name_entry_widget.focus_set()
            return
            
        try:
            num_subjects = int(num_subjects_str)
            if num_subjects <= 0:
                raise ValueError
        except ValueError:
            self.output_label.config(text="Number of subjects must be a positive integer.")
            self.num_subjects_entry_widget.focus_set()
            return

        self.student_name = name # Store for current session
        self.num_subjects = num_subjects
        
        self.clear_window()

        main_container = ttk.Frame(self.root, style='TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky='nsew')
        main_container.grid_rowconfigure(1, weight=1)
        main_container.grid_columnconfigure(0, weight=1)

        header_frame = ttk.Frame(main_container, padding="0 0 0 10")
        header_frame.grid(row=0, column=0, sticky='ew', padx=20, pady=(20, 10))
        
        ttk.Label(header_frame, text=f"Entering Data for: {self.student_name}", style='Header.TLabel').pack(side='left')
        ttk.Button(header_frame, text="‚Üê Back", style='Danger.TButton', 
                   command=lambda: self.reset_main_input(self.current_student_id)).pack(side='right', padx=(10,0))
        
        self.canvas = tk.Canvas(main_container, bg=BG_COLOR, highlightthickness=0)
        self.canvas.grid(row=1, column=0, sticky='nsew', padx=20, pady=10)
        
        scrollbar = ttk.Scrollbar(main_container, orient="vertical", command=self.canvas.yview)
        scrollbar.grid(row=1, column=1, sticky='ns', pady=10)
        
        scrollable_frame = ttk.Frame(self.canvas, padding="20")
        scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        )
        
        self.scrollable_frame_id = self.canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        self.canvas.bind('<Configure>', 
                         lambda e: self.canvas.itemconfig(self.scrollable_frame_id, width=self.canvas.winfo_width()))

        if self.canvas_scroll_bind_id:
            self.root.unbind("<MouseWheel>", self.canvas_scroll_bind_id)
        self.canvas_scroll_bind_id = self.root.bind("<MouseWheel>", lambda e: self.canvas.yview_scroll(int(-1*(e.delta/120)), "units"))

        self.subject_entries = []
        self.mark_entries = []
        self.credits_entries = []
        self.semester_entries = []

        initial_data = None
        if load_data and self.current_student_id:
            initial_data = self.db.get_student_details(self.current_student_id)['Subjects']

        # Subject entry form
        for i in range(num_subjects):
            subject_frame = ttk.Frame(scrollable_frame, padding="5 5")
            subject_frame.pack(fill='x', pady=5)
            
            subject_frame.columnconfigure(1, weight=2) 
            subject_frame.columnconfigure(3, weight=1)
            subject_frame.columnconfigure(5, weight=1)
            subject_frame.columnconfigure(7, weight=1)

            ttk.Label(subject_frame, text=f"Sub {i+1} Name:", font=(FONT_FAMILY, 10, 'bold')).grid(row=0, column=0, sticky='w', padx=(0, 5))
            sub_entry = ttk.Entry(subject_frame, font=(FONT_FAMILY, 10))
            sub_entry.grid(row=0, column=1, padx=(5, 10), sticky='ew')
            
            ttk.Label(subject_frame, text="Mark (0-100):", font=(FONT_FAMILY, 10, 'bold')).grid(row=0, column=2, sticky='w', padx=(0, 5))
            mark_entry = ttk.Entry(subject_frame, font=(FONT_FAMILY, 10), width=8)
            mark_entry.grid(row=0, column=3, sticky='ew')

            ttk.Label(subject_frame, text="Credits:", font=(FONT_FAMILY, 10, 'bold')).grid(row=0, column=4, sticky='w', padx=(10, 5))
            credits_entry = ttk.Entry(subject_frame, font=(FONT_FAMILY, 10), width=6)
            credits_entry.grid(row=0, column=5, sticky='ew')

            ttk.Label(subject_frame, text="Semester:", font=(FONT_FAMILY, 10, 'bold')).grid(row=0, column=6, sticky='w', padx=(10, 5))
            semester_entry = ttk.Entry(subject_frame, font=(FONT_FAMILY, 10), width=12)
            semester_entry.grid(row=0, column=7, sticky='ew')
            
            self.subject_entries.append(sub_entry)
            self.mark_entries.append(mark_entry)
            self.credits_entries.append(credits_entry)
            self.semester_entries.append(semester_entry)
            
            # Load existing data if available
            if load_data and initial_data and i < len(initial_data):
                sub_entry.insert(0, initial_data[i]['name'])
                mark_entry.insert(0, str(initial_data[i]['mark']))
                credits_entry.insert(0, str(initial_data[i]['credits']))
                semester_entry.insert(0, initial_data[i]['semester'] if initial_data[i]['semester'] else "")

            # Bind Enter key for sequential navigation
            sub_entry.bind('<Return>', lambda e, m=mark_entry: m.focus_set())
            mark_entry.bind('<Return>', lambda e, c=credits_entry: c.focus_set())
            credits_entry.bind('<Return>', lambda e, s=semester_entry: s.focus_set())

            if i < num_subjects - 1:
                def focus_next(i=i):
                    return lambda e: self.subject_entries[i+1].focus_set()
                semester_entry.bind('<Return>', focus_next())
            else:
                semester_entry.bind('<Return>', lambda e: self.store_student_data())
        
        button_frame = ttk.Frame(main_container, padding="20 0")
        button_frame.grid(row=2, column=0, columnspan=2, pady=(10, 20))
        
        ttk.Button(button_frame, text='Submit Data', style='Success.TButton', 
                   command=self.store_student_data).pack()
        
        self.output_label = ttk.Label(main_container, text='', foreground=ERROR_COLOR, font=(FONT_FAMILY, 10, 'italic'))
        self.output_label.grid(row=3, column=0, columnspan=2, pady=(5, 10))

    def store_student_data(self):
        subjects_data = []
        for i in range(self.num_subjects):
            sub = self.subject_entries[i].get().strip()
            mark_str = self.mark_entries[i].get().strip()
            credits_str = self.credits_entries[i].get().strip()
            semester = self.semester_entries[i].get().strip() or None # Store empty as None

            if not sub:
                self.output_label.config(text=f"Subject name for Subject {i+1} cannot be empty.")
                self.subject_entries[i].focus_set()
                return
            
            try:
                mark = float(mark_str)
                if not (0 <= mark <= 100):
                    raise ValueError
            except ValueError:
                self.output_label.config(text=f"Invalid mark for '{sub}' (Subject {i+1}). Must be a number between 0 and 100.")
                self.mark_entries[i].focus_set()
                return
            
            try:
                credits = int(credits_str)
                if credits < 0:
                    raise ValueError
            except ValueError:
                self.output_label.config(text=f"Invalid credits for '{sub}' (Subject {i+1}). Must be a non-negative integer.")
                self.credits_entries[i].focus_set()
                return

            subjects_data.append({"Subject Name": sub, "Mark": mark, "Credits": credits, "Semester": semester})
        
        if self.current_student_id: # Update existing student
            # Delete old subjects and add new ones
            self.db.delete_subjects_for_student(self.current_student_id)
            student_id_to_update = self.current_student_id
        else: # Add new student
            student_id_to_update = self.db.add_student(self.student_name, datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

        all_subject_details = [] # To pass to calculate_overall_gpa correctly
        for sub_data in subjects_data:
            subject_mark = sub_data["Mark"]
            subject_gpa = self.gpa_calculator._mark_to_gpa(subject_mark)
            grade = self.gpa_calculator._get_letter_grade(subject_mark)
            
            self.db.add_subject(student_id_to_update, sub_data["Subject Name"], subject_mark, 
                                 sub_data["Credits"], sub_data["Semester"], grade, subject_gpa)
            all_subject_details.append({
                'Mark': subject_mark,
                'Credits': sub_data["Credits"]
            })

        overall_gpa = self.gpa_calculator.calculate_overall_gpa(all_subject_details, weighted=True)
        self.db.update_student_gpa_info(student_id_to_update, overall_gpa, len(subjects_data))
        
        self.show_student_result(student_id_to_update)

    def show_student_result(self, student_id):
        self.clear_window()
        student_data = self.db.get_student_details(student_id)
        if not student_data:
            messagebox.showerror("Error", "Student data not found.")
            self.show_dashboard()
            return
            
        self.current_student_id = student_id # Ensure this is updated
        
        main_container = ttk.Frame(self.root, style='TFrame', padding="20")
        main_container.grid(row=0, column=0, sticky='nsew')
        main_container.grid_rowconfigure(2, weight=1)
        main_container.grid_columnconfigure(0, weight=1)

        header_frame = ttk.Frame(main_container, padding="0 0 0 10")
        header_frame.grid(row=0, column=0, sticky='ew', padx=20, pady=(20, 10))
        
        ttk.Label(header_frame, text=f"Academic Results: {student_data['name']}", style='Header.TLabel').pack(side='left')
        
        nav_frame = ttk.Frame(header_frame)
        nav_frame.pack(side='right')
        
        students_ids_list = [s['id'] for s in self.db.get_students()]
        current_index_in_list = students_ids_list.index(student_id) if student_id in students_ids_list else -1

        if current_index_in_list > 0:
            ttk.Button(nav_frame, text="‚Üê Previous Student", style='Primary.TButton', 
                       command=lambda: self.show_student_result(students_ids_list[current_index_in_list - 1])).pack(side='left', padx=5)
        
        ttk.Button(nav_frame, text="Back to Dashboard", style='Danger.TButton', 
                   command=self.show_dashboard).pack(side='left', padx=5)
        
        if current_index_in_list != -1 and current_index_in_list < len(students_ids_list) - 1:
            ttk.Button(nav_frame, text="Next Student ‚Üí", style='Primary.TButton', 
                       command=lambda: self.show_student_result(students_ids_list[current_index_in_list + 1])).pack(side='left', padx=5)
                       
        info_frame = ttk.Frame(main_container, borderwidth=1, relief='solid', padding=15, style='TFrame')
        info_frame.grid(row=1, column=0, sticky='ew', padx=20, pady=(0, 15))
        
        info_frame.columnconfigure(1, weight=1)
        info_frame.columnconfigure(3, weight=1)

        ttk.Label(info_frame, text="Student Name:", font=(FONT_FAMILY, 12, 'bold')).grid(row=0, column=0, sticky='w', padx=(0, 10))
        ttk.Label(info_frame, text=student_data['name'], font=(FONT_FAMILY, 12)).grid(row=0, column=1, sticky='w')
        
        ttk.Label(info_frame, text="Entry Date:", font=(FONT_FAMILY, 11, 'bold')).grid(row=0, column=2, sticky='e', padx=(20, 10))
        ttk.Label(info_frame, text=student_data['entry_date'], font=(FONT_FAMILY, 11)).grid(row=0, column=3, sticky='e')
        
        ttk.Label(info_frame, text="Number of Subjects:", font=(FONT_FAMILY, 11, 'bold')).grid(row=1, column=0, sticky='w', pady=(5, 0), padx=(0, 10))
        ttk.Label(info_frame, text=student_data['num_subjects'], font=(FONT_FAMILY, 11)).grid(row=1, column=1, sticky='w', pady=(5, 0))
        
        table_frame = ttk.Frame(main_container)
        table_frame.grid(row=2, column=0, sticky='nsew', padx=20, pady=5)
        
        columns = ("Subject", "Mark", "Credits", "Semester", "Grade", "Subject GPA")
        tree = ttk.Treeview(table_frame, columns=columns, show='headings', selectmode='browse')
        
        tree.heading("Subject", text="Subject", anchor='w')
        tree.heading("Mark", text="Mark", anchor='center')
        tree.heading("Credits", text="Credits", anchor='center')
        tree.heading("Semester", text="Semester", anchor='center')
        tree.heading("Grade", text="Grade", anchor='center')
        tree.heading("Subject GPA", text="Subject GPA", anchor='center')
        
        tree.column("Subject", width=200, anchor='w')
        tree.column("Mark", width=80, anchor='center')
        tree.column("Credits", width=80, anchor='center')
        tree.column("Semester", width=100, anchor='center')
        tree.column("Grade", width=80, anchor='center')
        tree.column("Subject GPA", width=100, anchor='center')
        
        for subject_data in student_data["Subjects"]:
            tree.insert("", "end", values=(
                subject_data["name"],
                f"{subject_data['mark']:.2f}",
                subject_data["credits"],
                subject_data["semester"] if subject_data["semester"] else "N/A",
                subject_data["grade"],
                f"{subject_data['subject_gpa']:.2f}"
            ))
        
        tree.pack(side="left", fill="both", expand=True)
        
        tree_scrollbar = ttk.Scrollbar(table_frame, orient="vertical", command=tree.yview)
        tree_scrollbar.pack(side="right", fill="y")
        tree.configure(yscrollcommand=tree_scrollbar.set)
        
        # Overall GPA display with emphasis
        overall_gpa_frame = ttk.Frame(main_container, borderwidth=1, relief='groove', padding=15, style='TFrame')
        overall_gpa_frame.grid(row=3, column=0, sticky='ew', padx=20, pady=(15, 10))
        
        ttk.Label(overall_gpa_frame, text="Overall GPA:",
                  font=(FONT_FAMILY, 16, 'bold'), foreground=HEADER_COLOR).pack(side='left', padx=(0, 10))
        ttk.Label(overall_gpa_frame, text=f"{student_data['cumulative_gpa']:.2f}",
                  font=(FONT_FAMILY, GPA_FONT_SIZE, 'bold'), foreground=HIGHLIGHT_COLOR).pack(side='left')
        
        # Export buttons
        export_button_frame = ttk.Frame(main_container, padding="10 0")
        export_button_frame.grid(row=4, column=0, sticky='ew', padx=20, pady=(10, 20))
        export_button_frame.columnconfigure(0, weight=1) 
        export_button_frame.columnconfigure(1, weight=1)
        export_button_frame.columnconfigure(2, weight=1)

        ttk.Button(export_button_frame, text="Export Student PDF", style='Info.TButton',
                   command=lambda: self._export_single_pdf(student_data)).grid(row=0, column=0, padx=7)
        ttk.Button(export_button_frame, text="Export Student CSV", style='Info.TButton',
                   command=lambda: self._export_single_csv(student_data)).grid(row=0, column=1, padx=7)
        ttk.Button(export_button_frame, text="Edit Student Data", style='Success.TButton',
                   command=lambda: self.reset_main_input(student_id=student_data['id'])).grid(row=0, column=2, padx=7)


    def _export_single_pdf(self, student_data):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            initialfile=f"{student_data['name'].replace(' ', '_')}_GPA_Report.pdf",
            title=f"Save {student_data['name']}'s GPA Report"
        )
        if not file_path:
            return
        try:
            self.report_generator.generate_pdf_report(student_data, file_path)
            messagebox.showinfo("Export Successful", f"PDF report saved to:\n{file_path}")
            webbrowser.open(file_path)
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export PDF: {e}")

    def _export_single_csv(self, student_data):
        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile=f"{student_data['name'].replace(' ', '_')}_Data.csv",
            title=f"Save {student_data['name']}'s GPA Data"
        )
        if not file_path:
            return
        try:
            self.csv_exporter.export_single_student_csv(student_data, file_path)
            messagebox.showinfo("Export Successful", f"CSV data saved to:\n{file_path}")
            webbrowser.open(os.path.dirname(file_path))
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export CSV: {e}")

    def _export_all_to_csv(self):
        all_students = self.db.get_students()
        if not all_students:
            messagebox.showinfo("No Data", "No student data to export.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv")],
            initialfile="All_Students_GPA_Report.csv",
            title="Save All Student GPA Data"
        )
        if not file_path:
            return
        try:
            self.csv_exporter.export_all_students_csv(all_students, file_path, self.db)
            messagebox.showinfo("Export Successful", f"All student data saved to:\n{file_path}")
            webbrowser.open(os.path.dirname(file_path))
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export all data to CSV: {e}")

    def _export_all_to_pdf(self):
        all_students = self.db.get_students()
        if not all_students:
            messagebox.showinfo("No Data", "No student data to export.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".pdf",
            filetypes=[("PDF files", "*.pdf")],
            initialfile="All_Students_GPA_Reports.pdf",
            title="Save All Students' GPA Report"
        )
        if not file_path:
            return
        try:
            self.report_generator.generate_all_pdf_report(all_students, file_path)
            messagebox.showinfo("Export Successful", f"All student reports combined into a single PDF saved to:\n{file_path}")
            webbrowser.open(file_path)
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export all data to PDF: {e}")


if __name__ == "__main__":
    root = tk.Tk()
    app = ProfessionalGPAApp(root)
    root.mainloop()
